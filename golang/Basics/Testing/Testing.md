#testing

В этой теме вы познакомитесь с базовыми возможностями для тестирования в экосистеме Go, а также поработаете с самой популярной библиотекой для тестов — `testify`.

Вы узнаете:

-   что такое юнит-тестирование;
-   как создавать и запускать тесты для Go-пакетов;
-   как определять процент покрытия кода тестами;
-   какие существуют паттерны тестирования;
-   зачем нужны и как использовать моки (заглушки).

# Юнит-тесты и покрытие кода

В этом уроке расскажем о том, как тестировать Go-код стандартными утилитами.

Существует множество видов функциональных и нефункциональных тестов:

-   **Юнит-тесты** — тестируют минимальную часть функциональности (функцию или методы) в полной изоляции от внешних зависимостей. По сути, тестируются отдельные небольшие кусочки кода.
-   **Интеграционные тесты** — тестируют взаимодействие нескольких крупных частей приложения, например систем оформления заказов и оплаты.
-   **End-to-end-тесты** — тестируют работоспособность всей системы.
-   **Мутационные тесты** — тестируют код на устойчивость к случайным изменениям.
-   **Нагрузочные тесты** — используются для определения максимальной нагрузки, которую система способна выдержать с допустимым уровнем деградации.

Напомним, что функциональные тесты проверяют работоспособность разработанного кода, то есть соответствие функциональным требованиям. Нефункциональные (например, нагрузочные) определяют соответствие кода требованиям надёжности, качества, сопровождения и т. п.

Сконцентрируемся на юнит-тестах, потому что:

-   Это самый простой для анализа вид тестов.
-   При правильном подходе к тестированию таких тестов в кодовой базе будет большинство.
-   Техники и приёмы, которые будут продемонстрированы на их примере, можно использовать и в других типах функциональных тестов.

Инструментарий языка Go, поставляемый вместе с компилятором, включает в себя обширные средства тестирования. Будем рассматривать именно их.

## Где размещаются юнит-тесты в Go?

В Go все тесты должны располагаться в файлах с суффиксом `_test.go`: например, `user_test.go`. Юнит-тесты принято располагать рядом с тестируемым кодом. Файлы `user.go` и `user_test.go` обычно лежат в одной и той же директории.

Файлы `*_test.go` не участвуют в компиляции финальной сборки проекта, поэтому можно не бояться импортировать в них большие библиотеки вроде `stretchr/testify`.

Тем не менее при компиляции тестов, как и основного кода, запрещены циклические импорты. Однако при написании тестов они могут возникать часто, поскольку в тестах может понадобиться код, который зависит от тестируемого кода. В таком случае тесты будут зависеть от тестируемого кода и, следовательно, импортировать сами себя. Поэтому для тестов сделали единственное исключение из правила «одна директория — один пакет». Тестовые файлы могут располагаться в пакете с суффиксом `_test` — и этой возможностью лучше пользоваться.

Также в пакете `_test` стоит располагать код, нужный исключительно для тестов. Допустим, надо сделать приватный тип публичным или добавить класс вспомогательных методов. Вспомогательный файл (часто его называют `harness_test.go` или `common_test`) может выглядеть так:

Скопировать кодGO

```
package user

import "context"

type UserDAO = userDAO

func (p *userProvider) ResetAllCaches(ctx context.Context) error {
    // сбрасываем кеши провайдера
} 
```

## Тесты в Go

Теперь, когда вы знаете, где и как хранить тестовый код, поговорим о том, как именно писать тесты на Go.

В Go все тесты — это функции вида:

Скопировать кодGO

```
func TestXxx(t *testing.T) 
```

Префикс `Test` обязателен. В качестве `Xxx` обычно указывают название тестируемой функции. У каждой тестируемой функции может быть несколько тестов, и тогда нужно указать дополнительную информацию по конкретному тесту.

Для примера протестируем функцию `Add`, которая должна сложить два числа при условии, что они положительные. Если одно или оба числа равны нулю, функция должна вернуть ошибку.

Файл `add.go`:

Скопировать кодGO

```
package math

import "errors"

func Add(a, b int) (int, error) {
    if a == 0 || b ==  0 {
        return 0, errors.New("arg is zero")
    }
    
    if a < 0 || b < 0 {
        return 0, errors.New("arg is negative")
    } 
    return a + b, nil
} 
```

Файл `add_test.go`:

Скопировать кодGO

```
package math

import "testing"

func TestAddPositive(t *testing.T) {
    sum, err := Add(1, 2)
    if err != nil {
        t.Error("unexpected error")
    }
    if sum != 3 {
        t.Errorf("sum expected to be 3; got %d", sum)
    }
}


func TestAddNegative(t *testing.T) {
    _, err := Add(-1, 2)
    if err == nil {
        t.Error("first arg negative - expected error not be nil" )
    }
    _, err = Add(1, -2)
    if err == nil {
        t.Error("second arg negative - expected error not be nil" )
    }
    _, err = Add(-1, -2)
    if err == nil {
        t.Error("all arg negative - expected error not be nil" )
    }
}
 
```

Объект `*testing.T` предоставляет доступ к нескольким базовым методам:

-   `Error`, `Errorf` — записывает сообщение в `error`-лог и помечает тест как непройденный. Исполнение теста продолжается.
-   `Fatal`, `Fatalf` — делает то же самое, но исполнение теста немедленно завершается. Этот метод часто используется в рабочих проектах при обработке ошибок. Очень удобен при отладке, когда тестируется какой-то конкретный участок кода.
-   `Skip`, `Skipf` — позволяет пропустить тест с сообщением. Используется, когда окружение для теста не задано. Типичный сценарий — прогон интеграционных тестов с внешним сервисом только на CI, где к нему есть доступы.
-   `Log`, `Logf` — позволяет выводить лог-сообщения внутри теста. Преимущество перед методами пакета `fmt` в том, что из лога сразу видно, к какому тесту относится сообщение.
-   `Run(name string, testf func(t *testing.T) )` — запускает функцию в качестве теста, что удобно при выполнении нескольких запусков теста, например, с разными именами.

## go test

Теперь разберём запуск написанных тестов. Для этого в экосистеме Go используется стандартная утилита [go test](https://golang.org/cmd/go/#hdr-Test_packages). Она позволяет запускать тесты следующими способами:

1.  Тесты на основании положения кода в директории. Чтобы запустить все тесты в директории, достаточно перейти в неё и выполнить команду `go test` или `go test -v`. Флаг `-v` перенаправляет на `stdout` всё, что тесты логируют в `stdout` и `stderr`.
2.  Все тесты пакета. Чтобы запустить все тесты в пакете, утилите `go test` надо передать пути импорта этих пакетов, разделённые пробелами. Например: `go test math github.com/username/packagename github.com/username/packagename2`.
3.  Тесты, подходящие под регулярное выражение. Также есть возможность протестировать некоторое подмножество тестов пакета. Для этого используется флаг `-run` утилиты `go test`.

Например, если нужно протестировать все тест-кейсы с префиксом `TestFunc` в пакете `github.com/ytuser/ytpackage`, вызов команды `go test` будет выглядеть так:

Скопировать кодBASH

```
go test github.com/ytuser/ytpackage -run ^TestFunc 
```

В качестве аргумента передаётся регулярное выражение, под которое должны подходить названия тестов. Вот только регулярные выражения выходят за пределы темы урока, и если вы не знакомы с ними, то лучше сперва прочитать эту [статью](https://habr.com/ru/post/545150/).

### Кеширование тестов

Если повторно запустим команду `go test <PACKAGE_NAME>`, то увидим, что вывод команды изменился. В случае с пакетом `math` получим:

Скопировать кодBASH

```
ok      math    (cached) 
```

Дело в том, что в режиме тестирования пакета `go test` кеширует результат прогона тестов и, если код и тесты не были изменены, использует закешированный результат.

Отключить кеширование можно двумя способами:

-   Передать флаг `-count 1`, который определяет, сколько раз нужно запустить каждый тест (по умолчанию — один). Соответственно, `-count 1` не изменяет количество запусков — если сравнивать со значением по умолчанию, — но выключает кеширование.
-   Запустить команду `go test clear`, очищающую кеш.

### Дополнительные настройки тестирования

-   `-cpu 1,2,4` — позволяет прогнать все тесты несколько раз с использованием разного количества потоков. Пригодится, если нужно протестировать параллельный код и убедиться, что на машинах с разным количеством ядер он будет работать корректно.
-   `-list regexp` — вместо того чтобы запускать тесты, `go test` выведет в консоль имена тестов, подходящих под переданное регулярное выражение.
-   `-parallel n` — позволяет параллельно выполнять тесты, которые в теле вызывают `t.Parallel`.
-   `-run regexp` — позволяет запускать конкретные тесты.
-   `-short` — если этот флаг передан, то `t.Short() == true`. В этом случае можно либо пропустить длительные тесты, либо урезать их функционал.
-   `-v` — подробное логирование. Даже в случае успешного прохождения тестов весь их лог будет выведен в консоль.