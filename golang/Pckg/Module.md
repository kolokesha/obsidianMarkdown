#basicsgolang #modules 
В этом уроке вы узнаете:

-   что такое модули и почему с ними лучше, чем без них;
-   как создать свой первый локальный модуль и запустить программу.

Начнём с подхода, при котором в системе может быть установлена только одна версия пакета, а его положение в файловой системе будет однозначно определено путём импорта.

У этого подхода есть существенные недостатки:

-   Нельзя устанавливать несколько версий одной и той же библиотеки, так как у них будет одинаковый путь импорта и Go не сможет их различить. Без работы с разными версиями библиотеки не обойтись, если на каком-то этапе её развития была нарушена обратная совместимость. Например, наше приложение может работать правильно только с определённой версией пакета, который используют другие приложения. Они могут захотеть что-нибудь изменить в этом пакете, и разрешение таких конфликтов обернётся настоящей катастрофой.
-   Нельзя свободно перемещать код по файловой системе. Если целевая директория находится за пределами `GOPATH/src`, код становится недоступен.

Сейчас такой подход применяется только для стандартных библиотек.

Эти и многие другие проблемы (например, невозможность хранить в проекте список его зависимостей, по аналогии с `package.json` в npm JavaScript или `requirements.txt` для pip в Python) решают модули. После выхода Go 1.16 модули стали способом разрешения зависимостей по умолчанию.

По [официальной документации](https://golang.org/ref/mod#modules-overview), модуль — это коллекция пакетов с общими версионированием и релизным циклом. Модули могут загружаться либо напрямую из систем контроля версий, либо с модульных прокси-серверов. О том, как устанавливать модули из внешних источников, поговорим в следующем уроке.

Проще говоря, это группа пакетов, которые хранятся и обновляются вместе. Даже ваше приложение будет являться модулем.

Метаинформация о модуле содержится в файле `go.mod` в корневой директории модуля. Полный список всех директив этого файла можно также найти в [документации](https://golang.org/ref/mod#modules-overview).

Метаинформация о модуле говорит о том, как он будет собираться, экспортироваться и какие будет использовать внешние зависимости.

В этом уроке разберём несколько базовых директив на примере создания локальных модулей, то есть расположенных в нашей файловой системе. Другие виды модулей рассмотрим в следующем уроке. Пример базируется на Go 1.17, поэтому в других версиях некоторые моменты могут отличаться.

## Создание модуля

Создадим новую директорию `ypmodule`:

Скопировать код

```
mkdir ypmodule
cd ypmodule 
```

Инициализируем модуль внутри директории стандартной утилитой `go mod`:

Скопировать код

```
go mod init ypmodule 
```

В директории создался файл `go.mod`, содержащий:

Скопировать код

```
module ypmodule

go 1.17 
```

Строка `module ypmodule` содержит путь импорта модуля — это префикс, относительно которого будут импортироваться все пакеты этого модуля. Например, чтобы импортировать пакет `somepackage` из модуля `ypmodule`, надо добавить в код строку:

Скопировать кодGO

```
import "ypmodule/somepackage" 
```

Следует отметить, что в большинстве случаев файл `go.mod` не редактируется вручную, а изменяется с помощью `go mod`.

В примере путь импорта — это одно слово `ypmodule`. Но путь может быть и полноценным URL. Например, `github.com/someuser/somerepo`. Такие пути будут рассмотрены далее.

Строка `go 1.17` указывает на версию Go, использованную при создании этого модуля.

Создадим в модуле пакет `calc` для работы с числами и поместим в него файл `math.go` с функцией сложения целых чисел.

Скопировать кодGO

```
package calc

func AddInts(a, b int) int {
    return a + b
} 
```

В примере для модуля `calc` создана отдельная директория. Но если не предполагается добавлять в модуль больше одного пакета, можно писать код прямо в директории с файлом `go.mod`.

Чтобы протестировать функциональность модуля, создадим рядом с `ypmodule` ещё один модуль — `main`. Файловая структура будет выглядеть так:

Скопировать код

```
.
├── main
└── ypmodule
    ├── calc
    │   └── math.go
    └── go.mod 
```

Для создания нового модуля выполним в `main` команду:

Скопировать код

```
go mod init main 
```

Создадим в новом модуле файл `main.go`, содержащий:

Скопировать кодGO

```
package main

import (
    "fmt"

    "ypmodule/calc"
)

func main() {
    fmt.Println(calc.AddInts(1, 2))
} 
```

Попробуем запустить функцию `main`. И получим ошибку:

Скопировать код

```
main.go:6:2: package ypmodule/calc is not in GOROOT (/usr/local/go/src/ypmodule/calc) 
```

Дело в том, что в файле `main/go.mod` не описано, где искать модуль `ypmodule`. Сначала Go пошёл в `GOROOT` и не обнаружил его. Затем Go увидел, что `ypmodule` не похож на URL, поэтому искать этот пакет в сети нет смысла.

Поскольку сейчас работаем с локальным модулем (то есть его код лежит только на нашей файловой системе), для определения его положения на локальном диске нужно воспользоваться директивой [replace](https://golang.org/ref/mod#go-mod-file-replace). После её добавления файл `main/go.mod` будет выглядеть так:

Скопировать код

```
module main

go 1.17

// директивой replace указываем положение корня 
// модуля ypmodule относительно main/go.mod
replace ypmodule => ../ypmodule  
```

Так как `ypmodule` содержит внутри себя другие пакеты и зависимости, их тоже нужно указать. Можно не знать о зависимостях и структуре этого модуля, но инструментарий в Go придёт на помощь.

Выполним команду `go get ypmodule`:

Скопировать кодSHELL

```
go get ypmodule

go get: added ypmodule v0.0.0-00010101000000-000000000000 
```

В `go.mod` появилась строка:

Скопировать код

```
require ypmodule v0.0.0-00010101000000-000000000000 // indirect 
```

Она указывает, какую конкретно версию модуля `ypmodule` будет использовать `main` при сборке. Комментарий `// indirect` подсказывает, что сам пакет `ypmodule` в коде не импортируется, только `calc`.

Запустим `main` ещё раз. Ура, всё заработало! Первые локальные модули успешно нашли друг друга.

## Когда нужно применять модули?

На практике — всегда. Модули дают разработчику очень много возможностей по управлению зависимостями программы. Преимущество модулей станет более понятным через один урок. Не стоит опасаться лишней сложности выполнения, так как почти всю работу по настройке модуля за вас может сделать среда разработки и инструментарий Go.